name: Build KernelSU for Beyond2LTE

on:
  workflow_dispatch:
    inputs:
      kernelsu_variant:
        description: 'KernelSU variant to build'
        required: true
        default: 'KernelSU-Next'
        type: choice
        options:
          - 'KernelSU-Next'
          - 'KernelSU'
      kernelsu_tag:
        description: 'KernelSU tag to build'
        required: true
        default: 'next'
        type: string
      susfs_repo:
        description: 'SUSFS repository to use'
        required: true
        default: 'https://github.com/iHagoss/susfs4ksu.git'
        type: choice
        options:
          - 'https://gitlab.com/simonpunk/susfs4ksu.git'
          - 'https://github.com/iHagoss/susfs4ksu.git'
          - 'https://github.com/iHagoss/susfs4ksu-begonia.git'
      device:
        description: 'Device to build for'
        required: true
        default: 'beyond2lte'
        type: choice
        options:
          - 'beyond2lte'
          - 'beyond1lte'
          - 'beyond0lte'
          - 'beyondx'
          - 'beyondxq'
          - 'beyond0q'
          - 'beyond1q'
          - 'beyond2q'

env:
  GITHUB_TOKEN: ${{ secrets.GH_PUSH_TOKEN }}
  ARCH: arm64
  SUBARCH: arm64
  DEVICE: ${{ inputs.device }}
  KERNEL_NAME: ExtremeKRNL-Nexus-KernelSU
  CLANG_VERSION: "18.0.0"
  BUILD_USER: iHagoss
  BUILD_HOST: github-actions

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout kernel source
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GH_PUSH_TOKEN }}
        fetch-depth: 0
        submodules: recursive # This will checkout the repo itself

    - name: Setup build environment
      run: |
        echo "Updating apt and installing build dependencies..."
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          bc \
          bison \
          flex \
          libssl-dev \
          libelf-dev \
          git \
          wget \
          curl \
          zip \
          unzip \
          python3 \
          python3-pip \
          ccache \
          clang \
          lld \
          llvm \
          gcc-aarch64-linux-gnu \
          gcc-arm-linux-gnueabihf
        echo "Build environment setup complete."

    - name: Setup ccache
      uses: actions/cache@v4
      with:
        path: ~/.ccache
        key: ccache-${{ env.DEVICE }}-${{ github.sha }}
        restore-keys: |
          ccache-${{ env.DEVICE }}-
      env:
        CCACHE_DIR: ~/.ccache

    - name: Configure ccache
      run: |
        echo "Configuring ccache..."
        ccache --set-config=max_size=2G
        ccache --set-config=compression=true
        ccache --zero-stats
        ccache --show-config
        echo "ccache configured."

    - name: Setup toolchain symlinks
      run: |
        echo "Setting up toolchain symlinks..."
        sudo mkdir -p /usr/local/bin
        
        # Create Android-specific symlinks for aarch64
        sudo ln -sf /usr/bin/aarch64-linux-gnu-gcc /usr/local/bin/aarch64-linux-android-gcc
        sudo ln -sf /usr/bin/aarch64-linux-gnu-g++ /usr/local/bin/aarch64-linux-android-g++
        sudo ln -sf /usr/bin/aarch64-linux-gnu-ar /usr/local/bin/aarch64-linux-android-ar
        sudo ln -sf /usr/bin/aarch64-linux-gnu-as /usr/local/bin/aarch64-linux-android-as
        sudo ln -sf /usr/bin/aarch64-linux-gnu-ld /usr/local/bin/aarch64-linux-android-ld
        sudo ln -sf /usr/bin/aarch64-linux-gnu-strip /usr/local/bin/aarch64-linux-android-strip
        sudo ln -sf /usr/bin/aarch64-linux-gnu-objcopy /usr/local/bin/aarch64-linux-android-objcopy
        sudo ln -sf /usr/bin/aarch64-linux-gnu-objdump /usr/local/bin/aarch64-linux-android-objdump
        sudo ln -sf /usr/bin/aarch64-linux-gnu-nm /usr/local/bin/aarch64-linux-android-nm
        sudo ln -sf /usr/bin/aarch64-linux-gnu-ranlib /usr/local/bin/aarch64-linux-android-ranlib
        
        # Create Android-specific symlinks for arm
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-gcc /usr/local/bin/arm-linux-androideabi-gcc
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-g++ /usr/local/bin/arm-linux-androideabi-g++
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-ar /usr/local/bin/arm-linux-androideabi-ar
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-as /usr/local/bin/arm-linux-androideabi-as
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-ld /usr/local/bin/arm-linux-androideabi-ld
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-strip /usr/local/bin/arm-linux-androideabi-strip
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-objcopy /usr/local/bin/arm-linux-androideabi-objcopy
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-objdump /usr/local/bin/arm-linux-androideabi-objdump
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-nm /usr/local/bin/arm-linux-androideabi-nm
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-ranlib /usr/local/bin/arm-linux-androideabi-ranlib
        
        # Verify toolchain setup
        echo "âœ… Toolchain setup complete!"
        echo "Clang version:"
        clang --version
        echo "GCC aarch64 version:"
        aarch64-linux-android-gcc --version
        echo "GCC arm version:"
        arm-linux-androideabi-gcc --version

    - name: Clone KernelSU as submodule
      run: |
        echo "Adding KernelSU as git submodule..."
        
        # Remove existing KernelSU directory if it exists
        rm -rf KernelSU
        
        # Clean submodule entries in .gitmodules if they exist from previous runs
        if grep -q "KernelSU" .gitmodules 2>/dev/null; then
            echo "Removing old KernelSU submodule entry..."
            git submodule deinit -f -- KernelSU || true
            git rm -f KernelSU || true
            rm -rf .git/modules/KernelSU || true
        fi

        if [ "${{ inputs.kernelsu_variant }}" == "KernelSU-Next" ]; then
          git submodule add --force --branch next https://github.com/iHagoss/KernelSU-Next.git KernelSU || { 
            echo "âŒ Failed to add KernelSU-Next as submodule!"; exit 1; 
          }
        else
          git submodule add --force --branch ${{ inputs.kernelsu_tag }} https://github.com/tiann/KernelSU.git KernelSU || { 
            echo "âŒ Failed to add KernelSU as submodule!"; exit 1; 
          }
        fi
        
        git submodule update --init --recursive
        
        # Set KSU_GIT_VERSION properly and export it for subsequent steps
        cd KernelSU
        KSU_VERSION=$(git describe --tags --always --dirty --match "v*" 2>/dev/null || git rev-parse --short HEAD 2>/dev/null || echo "unknown")
        cd ..
        echo "KSU_GIT_VERSION=$KSU_VERSION" >> $GITHUB_ENV # Make available to all subsequent steps
        export KSU_GIT_VERSION="$KSU_VERSION" # Make available to the current shell
        echo "KernelSU version set: $KSU_VERSION"
        
        echo "KernelSU submodule added successfully"
        echo "KernelSU directory contents:"
        ls -la KernelSU/

    - name: Clone SUSFS
      run: |
        echo "Cloning SUSFS from: ${{ inputs.susfs_repo }}"
        git clone --depth=1 ${{ inputs.susfs_repo }} susfs || { echo "âŒ Failed to clone SUSFS!"; exit 1; }
        
        echo "SUSFS directory contents:"
        ls -la susfs/

    - name: Integrate KernelSU
      run: |
        echo "Integrating KernelSU..."
        
        if [ ! -d "KernelSU" ]; then
          echo "âŒ KernelSU directory not found!"
          exit 1
        fi
        
        # KSU_GIT_VERSION is already exported from the previous step
        echo "Using KSU_GIT_VERSION for integration: $KSU_GIT_VERSION"
        
        # Find KernelSU kernel source directory
        KERNELSU_SOURCE_ROOT=""
        if [ -d "KernelSU/kernel" ]; then
          KERNELSU_SOURCE_ROOT="KernelSU/kernel"
          echo "âœ… Found KernelSU kernel directory: KernelSU/kernel"
        elif [ -d "KernelSU/ksu" ]; then
          KERNELSU_SOURCE_ROOT="KernelSU/ksu"
          echo "âœ… Found KernelSU ksu directory: KernelSU/ksu"
        else
          echo "âŒ KernelSU kernel files not found!"
          ls -la KernelSU/
          exit 1
        fi

        # Run KernelSU setup script (this is the preferred method)
        SETUP_SH_PATH="$KERNELSU_SOURCE_ROOT/setup.sh"
        if [ -f "$SETUP_SH_PATH" ]; then
          echo "Running KernelSU setup script: $SETUP_SH_PATH"
          chmod +x "$SETUP_SH_PATH"
          # Ensure KSU_GIT_VERSION is exported for the setup script
          bash "$SETUP_SH_PATH" || { echo "âŒ KernelSU setup failed during execution!"; exit 1; }
        else
          echo "âŒ KernelSU setup.sh script not found at $SETUP_SH_PATH. Manual integration might be needed if setup.sh is missing."
          # Fallback to copying files if setup.sh doesn't exist (less ideal but keeps process moving)
          echo "Attempting to manually copy KernelSU files..."
          cp -rf "$KERNELSU_SOURCE_ROOT"/* ./ || { echo "âŒ Manual KernelSU file copy failed!"; exit 1; }
        fi
        
        # Verify KernelSU integration
        if [ -f "ksu.c" ] || find . -name "ksu.c" -path "*/ksu/*" | head -1 | grep -q .; then
          echo "âœ… KernelSU files integrated successfully"
        else
          echo "âŒ KernelSU integration failed! 'ksu.c' not found after setup."
          exit 1
        fi

    - name: Integrate SUSFS
      run: |
        echo "Integrating SUSFS..."
        
        if [ ! -d "susfs" ]; then
          echo "âŒ SUSFS directory not found!"
          exit 1
        fi
        
        # Find SUSFS source directory
        SUSFS_SOURCE_ROOT=""
        if [ -d "susfs/kernel_patches" ]; then
          SUSFS_SOURCE_ROOT="susfs/kernel_patches"
        elif [ -d "susfs/kernel" ]; then
          SUSFS_SOURCE_ROOT="susfs/kernel"
        else
          echo "âš ï¸ No specific SUSFS kernel directory found, using root susfs directory"
          SUSFS_SOURCE_ROOT="susfs"
        fi

        # Copy SUSFS files if source directory exists
        if [ -n "$SUSFS_SOURCE_ROOT" ] && [ -d "$SUSFS_SOURCE_ROOT" ]; then
          echo "Copying SUSFS files from: $SUSFS_SOURCE_ROOT"
          cp -rf "$SUSFS_SOURCE_ROOT"/* ./
        fi
        
        # Run SUSFS setup script if it exists
        for script in setup.sh susfs/setup.sh "$SUSFS_SOURCE_ROOT/setup.sh"; do
          if [ -f "$script" ]; then
            echo "Running SUSFS setup script: $script"
            chmod +x "$script"
            bash "$script" || { echo "âš ï¸ SUSFS setup script failed, continuing..."; }
            break
          fi
        done
        
        echo "âœ… SUSFS integration completed"

    - name: Find and prepare defconfig
      run: |
        echo "Searching for defconfig files..."
        
        echo "Available config files in arch/arm64/configs/:"
        ls -la arch/arm64/configs/ | head -20
        
        DEFCONFIG_FOUND=false
        SELECTED_DEFCONFIG_BASENAME="" # Store just the filename, not the path
        
        # First, search for device-specific .config files (your kernel uses .config extension)
        for config in \
          ${DEVICE}.config \
          beyond2lte.config \
          beyond1lte.config \
          beyond0lte.config \
          beyondx.config; do
          
          if [ -f "arch/arm64/configs/$config" ]; then
            echo "âœ… Found device config: $config"
            SELECTED_DEFCONFIG_BASENAME="$config"
            DEFCONFIG_FOUND=true
            break
          fi
        done
        
        # If no device config found, try defconfig files
        if [ "$DEFCONFIG_FOUND" = false ]; then
          echo "No device .config found. Searching for _defconfig files..."
          for config in \
            exynos9820_defconfig \
            exynos9820-m62xx_defconfig \
            defconfig; do
            
            if [ -f "arch/arm64/configs/$config" ]; then
              echo "âœ… Found defconfig: $config"
              SELECTED_DEFCONFIG_BASENAME="$config"
              DEFCONFIG_FOUND=true
              break
            fi
          done
        fi
        
        # If still not found, try pattern matching
        if [ "$DEFCONFIG_FOUND" = false ]; then
          echo "No exact match found. Searching with patterns..."
          FOUND_CONFIG_PATH=$(find arch/arm64/configs -maxdepth 1 -name "*${{ inputs.device }}*" | head -1) # maxdepth for efficiency
          if [ -n "$FOUND_CONFIG_PATH" ]; then
            SELECTED_DEFCONFIG_BASENAME=$(basename "$FOUND_CONFIG_PATH")
            echo "âœ… Using device pattern config: $SELECTED_DEFCONFIG_BASENAME"
            DEFCONFIG_FOUND=true
          else
            FOUND_CONFIG_PATH=$(find arch/arm64/configs -maxdepth 1 -name "*beyond*" | head -1)
            if [ -n "$FOUND_CONFIG_PATH" ]; then
              SELECTED_DEFCONFIG_BASENAME=$(basename "$FOUND_CONFIG_PATH")
              echo "âœ… Using beyond pattern config: $SELECTED_DEFCONFIG_BASENAME"
              DEFCONFIG_FOUND=true
            else
              FOUND_CONFIG_PATH=$(find arch/arm64/configs -maxdepth 1 -name "*exynos*" | head -1)
              if [ -n "$FOUND_CONFIG_PATH" ]; then
                SELECTED_DEFCONFIG_BASENAME=$(basename "$FOUND_CONFIG_PATH")
                echo "âœ… Using exynos pattern config: $SELECTED_DEFCONFIG_BASENAME"
                DEFCONFIG_FOUND=true
              fi
            fi
          fi
        fi
        
        if [ "$DEFCONFIG_FOUND" = false ]; then
          echo "âŒ No suitable config found!"
          echo "All available configs:"
          ls -la arch/arm64/configs/
          exit 1
        else
          echo "DEFCONFIG_FILENAME=$SELECTED_DEFCONFIG_BASENAME" >> $GITHUB_ENV # Store just the filename
          echo "Final selected CONFIG filename: $SELECTED_DEFCONFIG_BASENAME"
          
          # Verify the config file actually exists at the full path
          if [ ! -f "arch/arm64/configs/$SELECTED_DEFCONFIG_BASENAME" ]; then
            echo "âŒ Selected config file does not exist: arch/arm64/configs/$SELECTED_DEFCONFIG_BASENAME"
            exit 1
          fi
        fi

    - name: Configure kernel
      run: |
        echo "Configuring kernel with config: ${{ env.DEFCONFIG_FILENAME }}"
        
        # Set KSU environment variable for make
        export KSU_GIT_VERSION="${{ env.KSU_GIT_VERSION }}"
        echo "Using KSU_GIT_VERSION: $KSU_GIT_VERSION"
        
        # Create the 'out' directory for out-of-tree builds
        mkdir -p out
        
        # Clean any previous build artifacts (ignore errors)
        make -C . O=out clean ARCH=$ARCH 2>/dev/null || true
        make -C . O=out mrproper ARCH=$ARCH 2>/dev/null || true
        
        # Determine the full path to the selected config file
        FULL_CONFIG_PATH="arch/arm64/configs/${{ env.DEFCONFIG_FILENAME }}"
        
        # Handle different config types
        if [[ "${{ env.DEFCONFIG_FILENAME }}" == *.config ]]; then
          # For .config files, we need to copy and then run olddefconfig (or merge_config.sh)
          echo "Processing .config file: ${{ env.DEFCONFIG_FILENAME }}"
          
          # Copy the chosen .config file to the output directory as .config
          cp "$FULL_CONFIG_PATH" out/.config || {
              echo "âŒ Failed to copy $FULL_CONFIG_PATH to out/.config";
              exit 1;
          }

          # If merge_config.sh is present, use it to ensure all config options are handled
          if [ -f scripts/kconfig/merge_config.sh ]; then
              echo "Running merge_config.sh to resolve .config..."
              make -C . O=out ARCH=$ARCH SUBARCH=$SUBARCH KSU_GIT_VERSION="$KSU_GIT_VERSION" olddefconfig || {
                  echo "âŒ Initial olddefconfig with merge_config.sh failed.";
                  exit 1;
              }
          else
              echo "scripts/kconfig/merge_config.sh not found. Proceeding with simple olddefconfig."
          fi
        else
          # Regular _defconfig file (e.g., exynos9820_defconfig)
          echo "Applying defconfig: ${{ env.DEFCONFIG_FILENAME }}"
          if ! make -C . O=out ARCH=$ARCH SUBARCH=$SUBARCH KSU_GIT_VERSION="$KSU_GIT_VERSION" ${{ env.DEFCONFIG_FILENAME }}; then
            echo "âŒ Failed to apply defconfig!"; 
            exit 1
          fi
        fi
        
        if [ ! -f out/.config ]; then # Check in the output directory
          echo "âŒ .config file was not created in out/!"
          exit 1
        fi

        # Now, modify the .config file directly within the 'out' directory
        echo "Adding KernelSU configuration to out/.config..."
        echo "CONFIG_KSU=y" >> out/.config
        echo "CONFIG_KSU_DEBUG=n" >> out/.config
        
        # Add SUSFS configuration if available
        # Check Kconfig in the source tree, apply to out/.config
        if grep -q "CONFIG_KSU_SUSFS" Kconfig 2>/dev/null || find . -name "Kconfig*" -exec grep -l "CONFIG_KSU_SUSFS" {} \; | head -1 | grep -q .; then
          echo "Adding SUSFS configuration to out/.config..."
          echo "CONFIG_KSU_SUSFS=y" >> out/.config
          echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> out/.config
          echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> out/.config
          echo "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=y" >> out/.config
        else
          echo "âš ï¸ SUSFS configuration not found in Kconfig"
        fi
        
        # Add ksu.config if available
        if [ -f "arch/arm64/configs/ksu.config" ]; then
          echo "Found ksu.config, merging into out/.config..."
          # Use merge_config.sh to properly merge into the out/.config
          if [ -f scripts/kconfig/merge_config.sh ]; then
            ./scripts/kconfig/merge_config.sh out/.config arch/arm64/configs/ksu.config || {
              echo "merge_config.sh failed for ksu.config, appending manually..."
              cat arch/arm64/configs/ksu.config >> out/.config
            }
          else
            echo "scripts/kconfig/merge_config.sh not found, appending ksu.config manually..."
            cat arch/arm64/configs/ksu.config >> out/.config
          fi
        fi
        
        # Resolve configuration dependencies with the modified .config
        echo "Resolving final configuration dependencies..."
        if ! make -C . O=out ARCH=$ARCH SUBARCH=$SUBARCH KSU_GIT_VERSION="$KSU_GIT_VERSION" olddefconfig; then
          echo "âŒ Final olddefconfig failed!"; 
          exit 1
        fi
        
        # Verify KernelSU is enabled in the final out/.config
        if grep -q "CONFIG_KSU=y" out/.config; then
          echo "âœ… KernelSU enabled in final configuration"
        else
          echo "âŒ KernelSU not enabled in final configuration!"
          exit 1
        fi
        
        echo "âœ… Kernel configuration completed"

    - name: Build kernel
      run: |
        echo "Starting kernel build..."
        
        # KSU_GIT_VERSION is already exported for this shell
        echo "Building with KSU_GIT_VERSION: $KSU_GIT_VERSION"
        
        # Build with multiple fallback options
        build_success=false
        
        # Try with clang first
        echo "Attempting build with clang..."
        if make -j$(nproc) \
          O=out \
          CC=clang \
          ARCH=$ARCH \
          SUBARCH=$SUBARCH \
          CROSS_COMPILE=aarch64-linux-android- \
          CROSS_COMPILE_ARM32=arm-linux-androideabi- \
          CLANG_TRIPLE=aarch64-linux-gnu- \
          KSU_GIT_VERSION="$KSU_GIT_VERSION" \
          CONFIG_NO_ERROR_ON_MISMATCH=y \
          2>&1 | tee build.log; then
          build_success=true
          echo "âœ… Build successful with clang"
        fi
        
        # If clang fails, try with GCC
        if [ "$build_success" = false ]; then
          echo "Clang build failed, trying with GCC..."
          
          # Clean output directory (relevant for O=out)
          make -C . O=out clean ARCH=$ARCH 2>/dev/null || true
          
          # Re-configure for GCC (similar logic as configure step, but to out/.config)
          echo "Re-configuring for GCC build..."
          FULL_CONFIG_PATH="arch/arm64/configs/${{ env.DEFCONFIG_FILENAME }}"
          if [[ "${{ env.DEFCONFIG_FILENAME }}" == *.config ]]; then
            cp "$FULL_CONFIG_PATH" out/.config || { echo "âŒ Failed to copy for GCC re-config"; exit 1; }
            if [ -f scripts/kconfig/merge_config.sh ]; then
                ./scripts/kconfig/merge_config.sh out/.config "$FULL_CONFIG_PATH" || true
            fi
          else
            make -C . O=out ARCH=$ARCH SUBARCH=$SUBARCH KSU_GIT_VERSION="$KSU_GIT_VERSION" ${{ env.DEFCONFIG_FILENAME }} || exit 1
          fi
          
          echo "CONFIG_KSU=y" >> out/.config # Ensure KSU is still enabled
          if grep -q "CONFIG_KSU_SUSFS" Kconfig 2>/dev/null || find . -name "Kconfig*" -exec grep -l "CONFIG_KSU_SUSFS" {} \; | head -1 | grep -q .; then
            echo "CONFIG_KSU_SUSFS=y" >> out/.config
            echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> out/.config
            echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> out/.config
            echo "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=y" >> out/.config
          fi
          if [ -f "arch/arm64/configs/ksu.config" ]; then
              if [ -f scripts/kconfig/merge_config.sh ]; then
                ./scripts/kconfig/merge_config.sh out/.config arch/arm64/configs/ksu.config || true
              else
                cat arch/arm64/configs/ksu.config >> out/.config
              fi
          fi
          
          make -C . O=out ARCH=$ARCH SUBARCH=$SUBARCH KSU_GIT_VERSION="$KSU_GIT_VERSION" olddefconfig || exit 1
          
          if make -j$(nproc) \
            O=out \
            ARCH=$ARCH \
            SUBARCH=$SUBARCH \
            CROSS_COMPILE=aarch64-linux-gnu- \
            KSU_GIT_VERSION="$KSU_GIT_VERSION" \
            CONFIG_NO_ERROR_ON_MISMATCH=y \
            2>&1 | tee -a build.log; then
            build_success=true
            echo "âœ… Build successful with GCC"
          fi
        fi
        
        if [ "$build_success" = false ]; then
          echo "âŒ Kernel build failed with both compilers!"
          echo "Last 50 lines of build log:"
          tail -50 build.log
          exit 1
        fi

    - name: Check build result
      run: |
        echo "Checking build result..."
        if [ -f out/arch/arm64/boot/Image ]; then
          echo "âœ… Kernel built successfully!"
          ls -la out/arch/arm64/boot/
          file out/arch/arm64/boot/Image
        else
          echo "âŒ Kernel build failed - Image not found!"
          echo "Boot directory contents:"
          find out/arch/arm64/ -name "Image*" -o -name "zImage*" -o -name "vmlinux*" | head -10
          exit 1
        fi

    - name: Prepare kernel image
      run: |
        echo "Preparing kernel image..."
        mkdir -p output
        
        cp out/arch/arm64/boot/Image output/
        # Also copy dtbo.img if it was generated and needed
        if [ -f out/arch/arm64/boot/dtbo.img ]; then
            cp out/arch/arm64/boot/dtbo.img output/
        fi
        
        TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
        KERNEL_ZIP="$KERNEL_NAME-$DEVICE-${{ inputs.kernelsu_variant }}-$TIMESTAMP.zip"
        echo "KERNEL_ZIP=$KERNEL_ZIP" >> $GITHUB_ENV
        
        KERNEL_VERSION=$(cat out/include/config/kernel.release 2>/dev/null || echo "unknown") # Read from out/
        echo "KERNEL_VERSION=$KERNEL_VERSION" >> $GITHUB_ENV
        
        cat > output/build_info.txt << EOF
        Kernel: $KERNEL_NAME
        Device: $DEVICE
        Version: $KERNEL_VERSION
        KernelSU: ${{ inputs.kernelsu_variant }} (${{ env.KSU_GIT_VERSION }}) # Use KSU_GIT_VERSION
        SUSFS: ${{ inputs.susfs_repo }}
        Built: $(date)
        Builder: $BUILD_USER
        Commit: $GITHUB_SHA
        EOF
        
        echo "âœ… Kernel preparation completed"

    - name: Create flashable zip
      run: |
        echo "Creating flashable zip..."
        mkdir -p anykernel3
        cd anykernel3
        
        wget -q https://github.com/osm0sis/AnyKernel3/archive/refs/heads/master.zip
        unzip -q master.zip
        cp -r AnyKernel3-master/* .
        rm -rf AnyKernel3-master master.zip
        
        # Configure AnyKernel3 for Samsung Exynos devices
        cat > anykernel.sh << EOF
        # AnyKernel3 Ramdisk Mod Script
        
        ## AnyKernel setup
        properties() { '
        kernel.string=$KERNEL_NAME
        do.devicecheck=1
        do.modules=0
        do.systemless=1
        do.cleanup=1
        do.cleanuponabort=0
        device.name1=${{ inputs.device }}
        device.name2=beyond2lte
        device.name3=SM-G975F
        device.name4=beyond1lte  
        device.name5=SM-G973F
        device.name6=beyond0lte
        device.name7=SM-G970F
        supported.versions=9-14
        supported.patchlevels=
        '; }
        
        # shell variables
        block=/dev/block/platform/13d60000.ufs/by-name/boot;
        is_slot_device=0;
        ramdisk_compression=auto;
        
        ## AnyKernel methods
        . tools/ak3-core.sh;
        
        ## AnyKernel file attributes
        # Ensure these paths are correct for your boot image structure
        set_perm_recursive 0 0 755 644 \$ramdisk/*;
        set_perm_recursive 0 0 750 750 \$ramdisk/init* \$ramdisk/sbin;
        
        ## AnyKernel boot install
        dump_boot;
        write_boot;
        EOF
        
        cp ../output/Image .
        if [ -f ../output/dtbo.img ]; then # Copy dtbo.img if present
            cp ../output/dtbo.img .
        fi
        
        zip -r ../output/$KERNEL_ZIP ./* -x "*.git*" "*.md" "*.txt"
        cd ..
        rm -rf anykernel3
        
        echo "âœ… Flashable zip created: $KERNEL_ZIP"
        ls -la output/

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.KERNEL_ZIP }}
        path: |
          output/${{ env.KERNEL_ZIP }}
          output/build_info.txt
          build.log

    - name: Create release
      uses: softprops/action-gh-release@v1
      if: github.ref == 'refs/heads/main' # Only create release on 'main' branch push
      with:
        tag_name: ${{ env.KERNEL_VERSION }}-${{ github.run_number }}
        name: ${{ env.KERNEL_NAME }} - ${{ env.KERNEL_VERSION }}
        body: |
          ## KernelSU Build for ${{ inputs.device }}
          
          **Device:** ${{ env.DEVICE }}
          **Kernel Version:** ${{ env.KERNEL_VERSION }}
          **KernelSU:** ${{ inputs.kernelsu_variant }} (${{ env.KSU_GIT_VERSION }})
          **SUSFS:** ${{ inputs.susfs_repo }}
          **Built:** $(date)
          
          ### Installation
          1. Boot into custom recovery (TWRP/CWM)
          2. Flash the kernel zip
          3. Reboot system
          4. Install KernelSU manager app
          
          ### Features
          - KernelSU root solution integrated
          - SUSFS (SystemUI Supplement File System) support
          - Optimized for Galaxy S10 series (Exynos 9820)
          - Compatible with Extreme ROM NEXUS
          
        files: |
          output/${{ env.KERNEL_ZIP }}
          output/build_info.txt
        token: ${{ secrets.GH_PUSH_TOKEN }}

    - name: Build summary
      run: |
        echo "## ðŸŽ‰ Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Status:** âœ… Success" >> $GITHUB_STEP_SUMMARY
        echo "- **Kernel:** $KERNEL_NAME" >> $GITHUB_STEP_SUMMARY
        echo "- **Device:** $DEVICE" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** $KERNEL_VERSION" >> $GITHUB_STEP_SUMMARY
        echo "- **KernelSU:** ${{ inputs.kernelsu_variant }} (${{ env.KSU_GIT_VERSION }})" >> $GITHUB_STEP_SUMMARY
        echo "- **SUSFS:** ${{ inputs.susfs_repo }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Output:** \`$KERNEL_ZIP\`" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ðŸ“Š Build Statistics" >> $GITHUB_STEP_SUMMARY
        ccache --show-stats >> $GITHUB_STEP_SUMMARY
