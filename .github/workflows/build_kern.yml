name: Build KernelSU for Beyond2LTE

on:
  workflow_dispatch:
    inputs:
      kernelsu_variant:
        description: 'KernelSU variant to build'
        required: true
        default: 'KernelSU-Next'
        type: choice
        options:
          - 'KernelSU-Next'
          - 'KernelSU'
      kernelsu_tag:
        description: 'KernelSU tag to build'
        required: true
        default: 'next'
        type: string
      susfs_repo:
        description: 'SUSFS repository to use'
        required: true
        default: 'https://gitlab.com/simonpunk/susfs4ksu.git'
        type: choice
        options:
          - 'https://gitlab.com/simonpunk/susfs4ksu.git'
          - 'https://github.com/iHagoss/susfs4ksu.git'
          - 'https://github.com/iHagoss/susfs4ksu-begonia.git'
      device:
        description: 'Device to build for'
        required: true
        default: 'beyond2lte'
        type: choice
        options:
          - 'beyond2lte'
          - 'beyond1lte'
          - 'beyond0lte'
          - 'beyondx'
          - 'beyondxq'
          - 'beyond0q'
          - 'beyond1q'
          - 'beyond2q'

env:
  GITHUB_TOKEN: ${{ secrets.GH_PUSH_TOKEN }}
  ARCH: arm64
  SUBARCH: arm64
  DEVICE: ${{ inputs.device }}
  # DEFCONFIG will be set dynamically in the "Find and prepare defconfig" step
  KERNEL_NAME: ExtremeKRNL-Nexus-KernelSU
  CLANG_VERSION: "18.0.0"
  BUILD_USER: iHagoss
  BUILD_HOST: github-actions

jobs:
  build:
    runs-on: ubuntu-22.04
    
    steps:
    - name: Checkout kernel source
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GH_PUSH_TOKEN }}
        fetch-depth: 0
        submodules: recursive

    - name: Setup build environment
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          build-essential \
          bc \
          bison \
          flex \
          libssl-dev \
          libelf-dev \
          git \
          wget \
          curl \
          zip \
          unzip \
          python3 \
          python3-pip \
          ccache \
          clang \
          lld \
          llvm \
          gcc-aarch64-linux-gnu \
          gcc-arm-linux-gnueabihf

    - name: Setup ccache
      uses: actions/cache@v4
      with:
        path: ~/.ccache
        key: ccache-${{ env.DEVICE }}-${{ github.sha }}
        restore-keys: |
          ccache-${{ env.DEVICE }}-

    - name: Configure ccache
      run: |
        ccache --set-config=max_size=2G
        ccache --set-config=compression=true
        ccache --zero-stats

    - name: Setup toolchain symlinks
      run: |
        sudo mkdir -p /usr/local/bin
        
        # Create Android-specific symlinks for aarch64
        sudo ln -sf /usr/bin/aarch64-linux-gnu-gcc /usr/local/bin/aarch64-linux-android-gcc
        sudo ln -sf /usr/bin/aarch64-linux-gnu-g++ /usr/local/bin/aarch64-linux-android-g++
        sudo ln -sf /usr/bin/aarch64-linux-gnu-ar /usr/local/bin/aarch64-linux-android-ar
        sudo ln -sf /usr/bin/aarch64-linux-gnu-as /usr/local/bin/aarch64-linux-android-as
        sudo ln -sf /usr/bin/aarch64-linux-gnu-ld /usr/local/bin/aarch64-linux-android-ld
        sudo ln -sf /usr/bin/aarch64-linux-gnu-strip /usr/local/bin/aarch64-linux-android-strip
        sudo ln -sf /usr/bin/aarch64-linux-gnu-objcopy /usr/local/bin/aarch64-linux-android-objcopy
        sudo ln -sf /usr/bin/aarch64-linux-gnu-objdump /usr/local/bin/aarch64-linux-android-objdump
        sudo ln -sf /usr/bin/aarch64-linux-gnu-nm /usr/local/bin/aarch64-linux-android-nm
        sudo ln -sf /usr/bin/aarch64-linux-gnu-ranlib /usr/local/bin/aarch64-linux-android-ranlib
        
        # Create Android-specific symlinks for arm
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-gcc /usr/local/bin/arm-linux-androideabi-gcc
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-g++ /usr/local/bin/arm-linux-androideabi-g++
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-ar /usr/local/bin/arm-linux-androideabi-ar
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-as /usr/local/bin/arm-linux-androideabi-as
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-ld /usr/local/bin/arm-linux-androideabi-ld
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-strip /usr/local/bin/arm-linux-androideabi-strip
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-objcopy /usr/local/bin/arm-linux-androideabi-objcopy
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-objdump /usr/local/bin/arm-linux-androideabi-objdump
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-nm /usr/local/bin/arm-linux-androideabi-nm
        sudo ln -sf /usr/bin/arm-linux-gnueabihf-ranlib /usr/local/bin/arm-linux-androideabi-ranlib
        
        # Verify toolchain setup
        echo "✅ Toolchain setup complete!"
        echo "Clang version:"
        clang --version
        echo "GCC aarch64 version:"
        aarch64-linux-android-gcc --version
        echo "GCC arm version:"
        arm-linux-androideabi-gcc --version

    - name: Clone KernelSU
      run: |
        echo "Cloning KernelSU variant: ${{ inputs.kernelsu_variant }}"
        echo "Using tag: ${{ inputs.kernelsu_tag }}"
        
        if [ "${{ inputs.kernelsu_variant }}" == "KernelSU-Next" ]; then
          git clone --depth=1 --branch ${{ inputs.kernelsu_tag }} https://github.com/KernelSU-Next/KernelSU-Next.git KernelSU
        else
          git clone --depth=1 --branch ${{ inputs.kernelsu_tag }} https://github.com/tiann/KernelSU.git KernelSU
        fi
        
        # Debug: Check what was cloned
        echo "KernelSU directory contents:"
        ls -la KernelSU/
        if [ -d "KernelSU/kernel" ]; then
          echo "KernelSU/kernel directory contents:"
          ls -la KernelSU/kernel/
        fi

    - name: Clone SUSFS
      run: |
        echo "Cloning SUSFS from: ${{ inputs.susfs_repo }}"
        git clone --depth=1 ${{ inputs.susfs_repo }} susfs
        
        # Debug: Check what was cloned
        echo "SUSFS directory contents:"
        ls -la susfs/
        if [ -d "susfs/kernel_patches" ]; then
          echo "SUSFS kernel_patches directory contents:"
          ls -la susfs/kernel_patches/
        fi

    - name: Integrate KernelSU
      run: |
        echo "Integrating KernelSU..."
        
        # Check if KernelSU directory exists and has content
        if [ ! -d "KernelSU" ]; then
          echo "❌ KernelSU directory not found!"
          exit 1
        fi
        
        # Find KernelSU kernel files - they might be in different locations
        # Copy KernelSU files to the root of the kernel source tree
        KERNELSU_SOURCE_DIR=""
        if [ -d "KernelSU/kernel" ]; then
          echo "✅ Found KernelSU kernel directory: KernelSU/kernel"
          cp -r KernelSU/kernel/* ./
          KERNELSU_SOURCE_DIR="KernelSU/kernel" # Store original path for later reference if needed
        elif [ -d "KernelSU/ksu" ]; then
          echo "✅ Found KernelSU ksu directory: KernelSU/ksu"
          cp -r KernelSU/ksu/* ./
          KERNELSU_SOURCE_DIR="KernelSU/ksu"
        else
          echo "❌ KernelSU kernel files not found in expected locations (KernelSU/kernel or KernelSU/ksu)"
          echo "Available directories in KernelSU:"
          find KernelSU -type d -maxdepth 2
          exit 1
        fi
        
        # Run KernelSU setup script if it exists, assuming it's now copied to the kernel root
        # and expects to run from there, using relative paths.
        if [ -f "setup.sh" ]; then
          echo "✅ Found KernelSU setup script (copied to kernel root), running it..."
          chmod +x setup.sh
          bash setup.sh
        elif [ -f "$KERNELSU_SOURCE_DIR/setup.sh" ]; then
          # Fallback: if setup.sh wasn't copied, but exists in the original cloned dir
          # This case is less ideal as it might cause pathing issues, but we try.
          echo "⚠️  KernelSU setup script not copied to kernel root, running from original cloned dir: $KERNELSU_SOURCE_DIR/setup.sh"
          chmod +x "$KERNELSU_SOURCE_DIR/setup.sh"
          bash "$KERNELSU_SOURCE_DIR/setup.sh"
        else
          echo "⚠️  KernelSU setup script not found in expected locations after copy. Manual integration may be needed or setup.sh is not applicable."
        fi
        
        # Verify KernelSU integration files. These files should now exist in the kernel root.
        if [ -f "ksu.c" ] || [ -f "kernel/ksu.c" ] || [ -d "KernelSU" ]; then
          echo "✅ KernelSU integration files appear successful (ksu.c or KernelSU dir exists in root)."
        else
          echo "⚠️  KernelSU integration verification failed: ksu.c not found in kernel root."
          # Optionally exit here if integration is critical and definitely failed.
          # exit 1 
        fi

    - name: Integrate SUSFS
      run: |
        echo "Integrating SUSFS..."
        
        # Check if SUSFS directory exists
        if [ ! -d "susfs" ]; then
          echo "❌ SUSFS directory not found!"
          exit 1
        fi
        
        SUSFS_INTEGRATED=false
        SUSFS_SOURCE_DIR=""
        
        # Method 1: Look for kernel_patches directory and copy contents
        if [ -d "susfs/kernel_patches" ]; then
          echo "✅ Found SUSFS kernel_patches directory: susfs/kernel_patches"
          cp -r susfs/kernel_patches/* ./
          SUSFS_INTEGRATED=true
          SUSFS_SOURCE_DIR="susfs/kernel_patches"
        fi
        
        # Method 2: Look for direct kernel files and copy contents
        if [ -d "susfs/kernel" ]; then
          echo "✅ Found SUSFS kernel directory: susfs/kernel"
          cp -r susfs/kernel/* ./
          SUSFS_INTEGRATED=true
          SUSFS_SOURCE_DIR="susfs/kernel"
        fi
        
        # Run SUSFS setup script if it exists, assuming it's now copied to the kernel root
        # or can operate on the kernel root from its original cloned location.
        if [ -f "susfs_setup.sh" ]; then # Check for a setup script specifically named for SUSFS if copied
            echo "✅ Found SUSFS setup script (copied to kernel root), running it..."
            chmod +x susfs_setup.sh
            bash susfs_setup.sh
        elif [ -f "$SUSFS_SOURCE_DIR/setup.sh" ]; then # Check original cloned path
          echo "✅ Found SUSFS setup script in cloned dir: $SUSFS_SOURCE_DIR/setup.sh, running it..."
          chmod +x "$SUSFS_SOURCE_DIR/setup.sh"
          bash "$SUSFS_SOURCE_DIR/setup.sh"
          SUSFS_INTEGRATED=true
        elif [ -f "susfs/setup.sh" ]; then # Check the root of the cloned susfs repo
          echo "✅ Found SUSFS setup script in susfs/setup.sh, running it..."
          chmod +x "susfs/setup.sh"
          bash "susfs/setup.sh"
          SUSFS_INTEGRATED=true
        fi
        
        if [ "$SUSFS_INTEGRATED" = false ]; then
          echo "⚠️  SUSFS integration method not found, but continuing..."
          echo "Available directories in susfs:"
          find susfs -type d -maxdepth 2
        else
          echo "✅ SUSFS integration completed"
        fi
        # Add a check for a known SUSFS file to verify success if possible.
        if [ -f "susfs.c" ] || grep -q "CONFIG_KSU_SUSFS" Kconfig 2>/dev/null; then # Example check
            echo "✅ SUSFS files/configs appear integrated."
        else
            echo "⚠️  SUSFS integration verification failed (no common SUSFS file/config found)."
        fi


    - name: Find and prepare defconfig
      run: |
        echo "Searching for defconfig files..."
        
        # Search for defconfig files
        echo "Available defconfig files:"
        find arch/arm64/configs -name "*${{ inputs.device }}*" -o -name "*beyond*" -o -name "*exynos9820*" | head -10
        
        # Try different defconfig names in order of preference
        DEFCONFIG_FOUND=false
        SELECTED_DEFCONFIG=""
        for config in ${{ inputs.device }}_defconfig ${DEVICE}_defconfig beyond2lte_defconfig beyond_defconfig exynos9820-beyond2lte_defconfig exynos9820_defconfig; do
          if [ -f "arch/arm64/configs/$config" ]; then
            echo "✅ Found defconfig: $config"
            SELECTED_DEFCONFIG="$config"
            DEFCONFIG_FOUND=true
            break
          fi
        done
        
        # Fallback to any defconfig with device name in it
        if [ "$DEFCONFIG_FOUND" = false ]; then
          FOUND_CONFIG=$(find arch/arm64/configs -name "*${{ inputs.device }}*" | head -1)
          if [ -n "$FOUND_CONFIG" ]; then
            SELECTED_DEFCONFIG=$(basename "$FOUND_CONFIG")
            echo "✅ Using fallback defconfig: $SELECTED_DEFCONFIG"
            DEFCONFIG_FOUND=true
          else
            # Last resort - try beyond configs
            FOUND_CONFIG=$(find arch/arm64/configs -name "*beyond*" | head -1)
            if [ -n "$FOUND_CONFIG" ]; then
              SELECTED_DEFCONFIG=$(basename "$FOUND_CONFIG")
              echo "✅ Using beyond fallback defconfig: $SELECTED_DEFCONFIG"
              DEFCONFIG_FOUND=true
            fi
          fi
        fi
        
        if [ "$DEFCONFIG_FOUND" = false ]; then
          echo "❌ No suitable defconfig found!"
          echo "Available defconfigs in arch/arm64/configs:"
          ls -la arch/arm64/configs/ | grep -E "(beyond|exynos|${{ inputs.device }})"
          exit 1
        else
          echo "DEFCONFIG=$SELECTED_DEFCONFIG" >> $GITHUB_ENV # Set environment variable for subsequent steps
        fi

    - name: Configure kernel
      run: |
        echo "Configuring kernel with defconfig: ${{ env.DEFCONFIG }}" # Use env.DEFCONFIG
        
        # Ensure we have a Makefile for clean
        if [ ! -f Makefile ]; then
          echo "❌ No Makefile found!"
          ls -la
          exit 1
        fi
        
        # Clean previous builds if targets exist
        make clean || true # Use || true to prevent job failure if clean/mrproper don't exist
        make mrproper || true
        
        # Configure with defconfig
        # The correct way to apply a defconfig is 'make <defconfig_name>'
        make CC=clang ARCH=$ARCH SUBARCH=$SUBARCH CROSS_COMPILE=aarch64-linux-android- CROSS_COMPILE_ARM32=arm-linux-androideabi- CLANG_TRIPLE=aarch64-linux-gnu- ${{ env.DEFCONFIG }}
        
        # Ensure .config exists after running defconfig
        if [ ! -f .config ]; then
            echo "❌ .config file was not created after running defconfig. Kernel configuration failed."
            exit 1
        fi

        echo "Current .config content before KSU/SUSFS additions:"
        cat .config | grep -E "CONFIG_KSU|CONFIG_KSU_SUSFS" || true # Show existing KSU/SUSFS lines

        # Enable KernelSU by appending to .config
        echo "CONFIG_KSU=y" >> .config
        echo "CONFIG_KSU_DEBUG=n" >> .config
        
        # Enable SUSFS if its config options are generally known or expected in the defconfig.
        # It's safer to check the *Kconfig* files or the defconfig for explicit support before adding.
        # A more robust check might be `grep -q "CONFIG_KSU_SUSFS" Kconfig` if SUSFS adds its own Kconfig entries.
        if grep -q "CONFIG_KSU_SUSFS" arch/arm64/configs/${{ env.DEFCONFIG }} 2>/dev/null || \
           grep -q "CONFIG_KSU_SUSFS" Kconfig 2>/dev/null; then # Check both defconfig and Kconfig for SUSFS entry
          echo "✅ Enabling SUSFS support in .config"
          echo "CONFIG_KSU_SUSFS=y" >> .config
          echo "CONFIG_KSU_SUSFS_SUS_MOUNT=y" >> .config
          echo "CONFIG_KSU_SUSFS_SUS_KSTAT=y" >> .config
          echo "CONFIG_KSU_SUSFS_SUS_OVERLAYFS=y" >> .config
        else
          echo "⚠️  SUSFS config options not found in defconfig or Kconfig. Skipping SUSFS config injection."
          # Optionally ensure they are off if not found, to prevent build issues from unwanted configs
          sed -i '/CONFIG_KSU_SUSFS/d' .config
          sed -i '/CONFIG_KSU_SUSFS_SUS_MOUNT/d' .config
          sed -i '/CONFIG_KSU_SUSFS_SUS_KSTAT/d' .config
          sed -i '/CONFIG_KSU_SUSFS_SUS_OVERLAYFS/d' .config
        fi
        
        # Regenerate config to pick up manual changes and resolve dependencies
        # This is crucial after modifying .config directly
        echo "Running olddefconfig to reconcile .config"
        make CC=clang ARCH=$ARCH SUBARCH=$SUBARCH CROSS_COMPILE=aarch64-linux-android- CROSS_COMPILE_ARM32=arm-linux-androideabi- CLANG_TRIPLE=aarch64-linux-gnu- olddefconfig
        
        # Verify KernelSU is enabled in the final .config
        if grep -q "CONFIG_KSU=y" .config; then
          echo "✅ KernelSU enabled in final .config"
        else
          echo "❌ KernelSU not found in final .config. Build might fail."
          exit 1 # Fail fast if KSU is not enabled after configuration
        fi
        # Verify SUSFS is enabled if it was supposed to be
        if grep -q "CONFIG_KSU_SUSFS=y" .config; then
            echo "✅ SUSFS enabled in final .config"
        fi
        
        echo "Final .config snippet:"
        cat .config | grep -E "CONFIG_KSU|CONFIG_KSU_SUSFS" || true

    - name: Build kernel
      run: |
        echo "Starting kernel build..."
        
        # Start build with verbose output
        make -j$(nproc) \
          CC=clang \
          ARCH=$ARCH \
          SUBARCH=$SUBARCH \
          CROSS_COMPILE=aarch64-linux-android- \
          CROSS_COMPILE_ARM32=arm-linux-androideabi- \
          CLANG_TRIPLE=aarch64-linux-gnu- \
          CONFIG_NO_ERROR_ON_MISMATCH=y \
          V=1 \
          2>&1 | tee build.log

    - name: Check build result
      run: |
        if [ -f arch/arm64/boot/Image ]; then
          echo "✅ Kernel built successfully!"
          echo "Kernel image details:"
          ls -la arch/arm64/boot/
          file arch/arm64/boot/Image
        else
          echo "❌ Kernel build failed!"
          echo "Build directory contents:"
          ls -la arch/arm64/boot/ || echo "Boot directory not found"
          echo ""
          echo "Last 100 lines of build log:"
          tail -100 build.log
          echo ""
          echo "Error summary (last 20 lines with 'error' keyword):"
          grep -i error build.log | tail -20
          echo "Warning summary (last 20 lines with 'warning' keyword):"
          grep -i warning build.log | tail -20
          exit 1
        fi

    - name: Prepare kernel image
      run: |
        mkdir -p output
        
        # Copy kernel image
        cp arch/arm64/boot/Image output/
        
        # Create kernel zip name with timestamp
        TIMESTAMP=$(date '+%Y%m%d_%H%M%S')
        KERNEL_ZIP="$KERNEL_NAME-$DEVICE-${{ inputs.kernelsu_variant }}-$TIMESTAMP.zip"
        echo "KERNEL_ZIP=$KERNEL_ZIP" >> $GITHUB_ENV
        
        # Get kernel version
        KERNEL_VERSION=$(cat include/config/kernel.release 2>/dev/null || echo "unknown")
        echo "KERNEL_VERSION=$KERNEL_VERSION" >> $GITHUB_ENV
        
        # Create info file
        cat > output/build_info.txt << EOF
        Kernel: $KERNEL_NAME
        Device: $DEVICE
        Version: $KERNEL_VERSION
        KernelSU: ${{ inputs.kernelsu_variant }} (${{ inputs.kernelsu_tag }})
        SUSFS: ${{ inputs.susfs_repo }}
        Built: $(date)
        Builder: $BUILD_USER
        Commit: $GITHUB_SHA
        EOF
        
        echo "✅ Kernel preparation completed"

    - name: Create flashable zip
      run: |
        mkdir -p output/anykernel3_temp # Create a temporary directory for AnyKernel3
        cd output/anykernel3_temp
        
        # Download AnyKernel3
        echo "Downloading AnyKernel3..."
        wget -q https://github.com/osm0sis/AnyKernel3/archive/refs/heads/master.zip
        unzip -q master.zip
        cp -r AnyKernel3-master/* .
        rm -rf AnyKernel3-master master.zip
        
        # Configure AnyKernel3 for selected device
        # Use single quotes for the EOF block to prevent shell variable expansion prematurely
        cat > anykernel.sh << 'EOF'
        # AnyKernel3 Ramdisk Mod Script
        # osm0sis @ xda-developers
        
        ## AnyKernel setup
        # begin properties
        properties() { '
        kernel.string=ExtremeKRNL-Nexus-KernelSU
        do.devicecheck=1
        do.modules=0
        do.systemless=1
        do.cleanup=1
        do.cleanuponabort=0
        device.name1=${{ env.DEVICE }} # Use env.DEVICE here
        device.name2=beyond2lte
        device.name3=SM-G975F
        device.name4=beyond1lte
        device.name5=SM-G973F
        supported.versions=9-14
        supported.patchlevels=
        '; } # end properties
        
        # shell variables
        block=/dev/block/platform/13d60000.ufs/by-name/boot;
        is_slot_device=0;
        ramdisk_compression=auto;
        
        ## AnyKernel methods (DO NOT CHANGE)
        # import patching functions/variables - see for reference
        . tools/ak3-core.sh;
        
        ## AnyKernel file attributes
        # set permissions/ownership for included ramdisk files
        set_perm_recursive 0 0 755 644 $ramdisk/*;
        set_perm_recursive 0 0 750 750 $ramdisk/init* $ramdisk/sbin;
        
        ## AnyKernel boot install
        dump_boot;
        write_boot;
        EOF
        
        # Copy kernel image from parent directory
        cp ../Image .
        
        # Create zip in the parent directory (output/)
        zip -r ../${{ env.KERNEL_ZIP }} * -x "*.git*" "*.md" "*.txt"
        
        cd ../.. # Go back to the root of the repo
        rm -rf output/anykernel3_temp # Clean up temporary AnyKernel3 directory
        echo "✅ Flashable zip created: output/${{ env.KERNEL_ZIP }}"
        ls -la output/${{ env.KERNEL_ZIP }}

    - name: Upload artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.KERNEL_ZIP }}
        path: |
          output/${{ env.KERNEL_ZIP }}
          output/build_info.txt
          build.log

    - name: Create release
      uses: softprops/action-gh-release@v1
      if: github.ref == 'refs/heads/main'
      with:
        tag_name: ${{ env.KERNEL_VERSION }}-${{ github.run_number }}
        name: ${{ env.KERNEL_NAME }} - ${{ env.KERNEL_VERSION }}
        body: |
          ## KernelSU Build for ${{ inputs.device }}
          
          **Device:** ${{ env.DEVICE }}
          **Kernel Version:** ${{ env.KERNEL_VERSION }}
          **KernelSU:** ${{ inputs.kernelsu_variant }} (${{ inputs.kernelsu_tag }})
          **SUSFS:** ${{ inputs.susfs_repo }}
          **Built:** $(date)
          
          ### Installation
          1. Boot into custom TWRP (Extreme's version)
          2. Flash the kernel zip
          3. Reboot
          4. Install KernelSU manager app
          
          ### Features
          - KernelSU integrated
          - SUSFS support
          - Optimized for Extreme ROM NEXUS
          - Self-healing build system
          
        files: |
          output/${{ env.KERNEL_ZIP }}
          output/build_info.txt
        token: ${{ secrets.GH_PUSH_TOKEN }}

    - name: Build summary
      run: |
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "- **Status:** ✅ Success" >> $GITHUB_STEP_SUMMARY
        echo "- **Kernel:** $KERNEL_NAME" >> $GITHUB_STEP_SUMMARY
        echo "- **Device:** $DEVICE" >> $GITHUB_STEP_SUMMARY
        echo "- **Version:** $KERNEL_VERSION" >> $GITHUB_STEP_SUMMARY
        echo "- **KernelSU:** ${{ inputs.kernelsu_variant }} (${{ inputs.kernelsu_tag }})" >> $GITHUB_STEP_SUMMARY
        echo "- **SUSFS:** ${{ inputs.susfs_repo }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Output:** $KERNEL_ZIP" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ccache stats" >> $GITHUB_STEP_SUMMARY
        ccache --show-stats >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### ccache stats" >> $GITHUB_STEP_SUMMARY
        ccache --show-stats >> $GITHUB_STEP_SUMMARY
